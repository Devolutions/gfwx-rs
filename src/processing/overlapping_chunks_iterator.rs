use std::mem;

pub struct OverlappingChunksIterator<'a, T>
where
    T: 'a,
{
    head: &'a [T],
    remainder: &'a mut [T],
}

impl<'a, T> OverlappingChunksIterator<'a, T> {
    pub fn from_slice(slice: &'a mut [T], step: usize) -> OverlappingChunksIterator<'a, T> {
        if slice.len() <= step {
            // valid, but no elements will be generated by iterator
            OverlappingChunksIterator {
                head: &mut [],
                remainder: &mut [],
            }
        } else {
            // normal behavior
            let (head, remainder) = slice.split_at_mut(step);
            OverlappingChunksIterator { head, remainder }
        }
    }
}

impl<'a, T> Iterator for OverlappingChunksIterator<'a, T> {
    type Item = (&'a [T], &'a mut [T], &'a [T]);

    fn next(&mut self) -> Option<Self::Item> {
        let left_slice = self.head;

        if self.remainder.len() == 0 {
            return None;
        }

        // no right nighbour chunk
        if self.remainder.len() <= left_slice.len() {
            let mut middle_slice: &'a mut [T] = &mut [];
            mem::swap(&mut middle_slice, &mut self.remainder);
            return Some((left_slice, middle_slice, &[]));
        }

        let mut remainder: &mut [T] = &mut [];
        mem::swap(&mut remainder, &mut self.remainder);

        let (middle_slice, mut remainder) = remainder.split_at_mut(left_slice.len());

        // right slice is incomplete, but iterator is effectively finished
        if remainder.len() <= left_slice.len() {
            let mut right_slice: &'a mut [T] = &mut [];
            mem::swap(&mut right_slice, &mut remainder);
            return Some((left_slice, middle_slice, right_slice));
        }

        let (right_slice, remainder) = remainder.split_at_mut(left_slice.len());

        self.head = right_slice;
        self.remainder = remainder;

        Some((left_slice, middle_slice, right_slice))
    }
}
